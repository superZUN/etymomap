{"version":3,"sources":["WordCards.js","Routes/EtymomapPresenter.js","App.js","serviceWorker.js","index.js"],"names":["React","Component","WordcardSophie","circleSizeRate","standardLength","window","innerWidth","innerHeight","length","circleSize","FontSize","getX","c","i","center","prevAngle","angle","Math","PI","sin","getY","cos","Welcome","props","windowW","windowH","countOfFirstLayer","data","countOfSecondLayerArr","arrX","arrY","arrLineX","arrLineY","arrLineAngle","arrLineLength","push","x","y","shift","j","x2","y2","CreateWordCard","word","meanWord","wordDescription","layer","id","posX","posY","useState","clicked","setClicked","hasClicked","setHasClicked","useSpring","config","stiff","zIndex","opacity","left","top","width","height","fontSize","from","immediate","key","style","setStyle","pop","transform","lineStyle","meaningStyle","setMeaningStyle","div","className","onClick","clickWordCard","document","getElementById","value","click","onTouchEnd","event","onMouseLeave","onTouchStart","console","log","onMouseEnter","map","wordPKG","index","EtymomapPresenter","words","loading","searchTerm","handleSubmit","updateTerm","align","onSubmit","blurOnSubmit","position","autoFocus","placeholder","onChange","keyword","Wordboard","setWords","setSearchTerm","setLoading","error","setError","a","axios","get","then","hideVirtualKeyboard","catch","err","useEffect","searchByTerm","preventDefault","target","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.76fb0f29.chunk.js","sourcesContent":["import React from \"react\";\nimport { useSpring, animated } from \"react-spring\";\n\nconst circleSize = 100;\nconst circleSizeRate = 1.7;\n\nclass Wordcard extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: null,\n      styleName: null,\n      posX: null,\n      posY: null\n    };\n  }\n  componentDidMount() {\n    // console.log(this.state.name);\n    this.setState((state, props) => ({\n      name: props.name,\n      styleName: props.styleName,\n      posX: props.posX,\n      posY: props.posY\n    }));\n    // this.timerID = setInterval(() => this.tick(), 1000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n  tick() {\n    this.setState({\n      date: new Date()\n    });\n  }\n  render() {\n    return (\n      <>\n        <div>\n          <animated.div\n            className={this.state.name + \" word circleBase\"}\n            style={this.state.styleName}\n          >\n            <p>{this.state.name}</p>\n            {/* It is {this.state.date.toLocaleTimeString()}. */}\n          </animated.div>\n        </div>\n        <animated.div className=\"line\"> </animated.div>\n      </>\n    );\n  }\n}\n\nfunction NewWordStyle(x, y, layer) {\n  let FontSize = [];\n  FontSize = [30, 20, 15, 15];\n\n  const style = useSpring({\n    opacity: 0.7,\n    left: x,\n    top: y,\n    width: (circleSize / (layer + 1)) * circleSizeRate + \"px\",\n    height: (circleSize / (layer + 1)) * circleSizeRate + \"px\",\n    fontSize: FontSize[layer],\n    from: {\n      opacity: 0,\n      left: window.innerWidth / 2,\n      top: window.innerHeight / 2\n    }\n  });\n  return style;\n}\n\nfunction WordcardSophie() {\n  const stArray = [];\n  const layerCount = [3, 3, 4, 3];\n  /* root + layer1 + layer2-1\n        |        + layer2-2\n        |        + layer2-3\n        + layer2 + layer2-1\n        |        + layer2-2\n        |        + layer2-3\n        |        + layer2-4\n        + layer3 + layer3-1\n                   layer3-2\n                   layer3-3\n\n*/\n\n  const length = 150;\n  const windowW = window.innerWidth / 2;\n  const windowH = window.innerHeight / 2;\n  let data = [\n    [0, \"sophie\", 1, 100, 100, null],\n    [1, \"jun\", 2, 200, 200, null],\n    [2, \"Jiwoo\", 2, 300, 300, null],\n    [3, \"Tory\", 2, 400, 400, null]\n  ];\n\n  stArray.push(NewWordStyle(windowW, windowH, 1));\n  for (let i = 0; i < layerCount[0]; i++) {\n    stArray.push(\n      NewWordStyle(\n        length * Math.sin(((2 * Math.PI) / 3) * i) + windowW,\n        length * Math.cos(((2 * Math.PI) / 3) * i) + windowH,\n        data[i + 1][2]\n      )\n    );\n  }\n  stArray.reverse();\n\n  data.map(word => (word[5] = stArray.pop()));\n\n  return (\n    <>\n      {data.map(word => (\n        <Wordcard\n          name={word[1]}\n          refer={word[2]}\n          styleName={word[5]}\n          posX={word[3]}\n          posY={word[4]}\n        />\n      ))}\n    </>\n  );\n}\n\nexport default WordcardSophie;\n","import React, { useState } from \"react\";\nimport { useSpring, animated, config } from \"react-spring\";\n\nlet circleSizeRate = 3;\nlet standardLength =\n  window.innerWidth > window.innerHeight\n    ? window.innerHeight\n    : window.innerWidth;\n\nlet length = (standardLength * 3.5) / 15;\nif (length > 150) length = 150;\n\nlet circleSize = standardLength / 16;\n\n// console.log(circleSize);\n\nlet FontSize = [];\nFontSize = [\n  standardLength / 40,\n  standardLength / 45,\n  standardLength / 50,\n  standardLength / 50,\n  standardLength / 50,\n  standardLength / 50,\n  standardLength / 50,\n];\n// console.log(\"width:\", window.innerWidth);\nif (window.innerWidth < 400) {\n  circleSizeRate = 3;\n  FontSize = [17, 12, 10, 10, 10, 10, 10];\n}\n\nfunction getX(c, i, center, prevAngle) {\n  const angle = prevAngle + ((2 * Math.PI) / c) * i + 0.5 * Math.PI;\n  if (\n    length * Math.sin(angle) + center <\n    (circleSize / (3 + 1)) * circleSizeRate\n  ) {\n    return (circleSize / (2 + 1)) * circleSizeRate;\n  } else if (\n    length * Math.sin(angle) + center >\n    window.innerWidth - (circleSize / (2 + 1)) * circleSizeRate\n  ) {\n    return window.innerWidth - (circleSize / (2 + 1)) * circleSizeRate;\n  }\n  return length * Math.sin(angle) + center;\n}\nfunction getY(c, i, center, prevAngle) {\n  const angle = prevAngle + ((2 * Math.PI) / c) * i + 0.5 * Math.PI;\n  return length * Math.cos(angle) + center;\n}\n\nfunction updateDimensions() {\n  // console.log(\"resized\");\n}\n\nfunction Welcome(props) {\n  const windowW = window.innerWidth / 2;\n  const windowH = window.innerHeight / 2;\n  // console.log(\"welcome props : \", props);\n  const countOfFirstLayer = props.data.data.length - 1;\n  const countOfSecondLayerArr = [];\n  let arrX = [];\n  let arrY = [];\n\n  // let arrLine = [start X(X of origin), start Y(Y of origin), angle, length]\n  let arrLineX = [];\n  let arrLineY = [];\n  let arrLineAngle = [];\n  let arrLineLength = [];\n\n  //Root word\n  arrX.push(windowW);\n  arrY.push(windowH);\n  arrLineAngle.push(0);\n  arrLineX.push(windowW);\n  arrLineY.push(windowH);\n  arrLineLength.push(0);\n  // stArr.push(NewWordStyle(windowW, windowH, 1));\n\n  //First layer\n  for (let i = 0; i < countOfFirstLayer; i++) {\n    const x = getX(countOfFirstLayer, i, windowW, 0);\n    const y = getY(countOfFirstLayer, i, windowH, 0);\n    const layer = 2;\n    arrX.push(x);\n    arrY.push(y);\n    arrLineAngle.push(((2 * Math.PI) / countOfFirstLayer) * i + 0.5 * Math.PI);\n    arrLineX.push(windowW);\n    arrLineY.push(windowH);\n    arrLineLength.push(length);\n    // stArr.push(NewWordStyle(x, y, layer));\n  }\n\n  //Second layer\n  for (let i = 1; i < props.data.data.length; i++) {\n    // console.log(props.data.data);\n    props.data.data[i].shift();\n    const x = getX(countOfFirstLayer, i - 1, windowW, 0);\n    const y = getY(countOfFirstLayer, i - 1, windowH, 0);\n    const prevAngle = ((2 * Math.PI) / countOfFirstLayer) * (i - 1) + Math.PI;\n    countOfSecondLayerArr.push(props.data.data[i].length);\n    for (let j = 0; j < props.data.data[i].length; j++) {\n      const x2 = getX(\n        countOfSecondLayerArr[i - 1] + 5,\n        j + 3, // + countOfSecondLayerArr[i - 1],\n        x,\n        prevAngle\n      );\n      const y2 = getY(\n        countOfSecondLayerArr[i - 1] + 5,\n        j + 3, // + countOfSecondLayerArr[i - 1],\n        y,\n        prevAngle\n      );\n      arrX.push(x2);\n      arrY.push(y2);\n      // console.log(\"prevAngle:\", (prevAngle / Math.PI) * 180);\n      // console.log(\"countofsecond:\", countOfSecondLayerArr[i - 1]);\n      // console.log(\"i:\", i);\n      // console.log(\"j:\", j);\n      // console.log(\n      //   \"angle:\",\n      //   ((prevAngle -\n      //     ((2 * Math.PI) / (countOfSecondLayerArr[i - 1] + 5)) * (j + 3) +\n      //     0.5 * Math.PI) *\n      //     180) /\n      //     Math.PI -\n      //     90\n      // );\n      arrLineAngle.push(\n        0 -\n          prevAngle +\n          ((2 * Math.PI) / (countOfSecondLayerArr[i - 1] + 5)) * (j + 3) +\n          0.5 * Math.PI\n      );\n      arrLineX.push(x);\n      arrLineY.push(y);\n      arrLineLength.push(length);\n      // stArr.push(NewWordStyle(x2, y2, 3));\n    }\n  }\n  // console.log(\"arrLineX\", arrLineX);\n\n  // // check layer inspection\n  // console.log(\"here's array X\", arrX);\n  // console.log(\"here's array Y\", arrY);\n  // console.log(\"here's radius : \", props.layer);\n  // console.log(\"1st layer's count : \", countOfFirstLayer);\n  // console.log(\"1st layer's count : \", countOfSecondLayerArr);\n  // console.log(\"how long is array \", arrX.length);\n\n  // for (let i = 1; i < arrX.length; i++) {\n  //   for (let j = 0; j < i; j++) {\n  //     console.log(\n  //       \"x, y\" + arrX[i] + \",\" + arrY[i] + \" - \" + arrX[j] + \",\" + arrY[j]\n  //     );\n  //     console.log(\n  //       \"Distance(센터부터 잡고 계산할 것!) : \",\n  //       getDistance(arrX[i], arrY[i], arrX[j], arrY[j])\n  //     );\n  //   }\n  // }\n  function getDistance(x1, y1, x2, y2) {\n    return Math.sqrt(Math.abs(x2 - x1) ^ (2 + Math.abs(y2 - y1)) ^ 2);\n  }\n\n  function CreateWordCard(props) {\n    const word = props.word[0];\n    const meanWord = props.word[1];\n    const wordDescription = props.word[2];\n    // console.log(props.word);\n\n    let layer = props.layer;\n    if (props.id === 0) {\n      layer = 0;\n    }\n    if (layer > 2) layer = 2;\n    let x = props.posX;\n    let y = props.posY;\n\n    const [clicked, setClicked] = useState(false);\n    const [hasClicked, setHasClicked] = useState(false);\n\n    const [style, setStyle] = useSpring(() => ({\n      config: config.stiff,\n      zIndex: 100,\n      opacity: 1,\n      left: clicked ? x + 400 : x,\n      top: y,\n      width: (circleSize / (layer + 1)) * circleSizeRate + \"px\",\n      height: (circleSize / (layer + 1)) * circleSizeRate + \"px\",\n      fontSize: FontSize[layer],\n      from: {\n        opacity: 0,\n        left: window.innerWidth / 2,\n        top: window.innerHeight / 2,\n      },\n      immediate: (key) => key === \"zIndex\",\n    }));\n\n    const [lineStyle, setLineStyle] = useSpring(() => ({\n      config: config.stiff,\n      zIndex: 0,\n      left: arrLineX.pop(),\n      top: arrLineY.pop(),\n      transform:\n        \"rotateZ(\" + ((arrLineAngle.pop() / Math.PI) * 180 - 90) + \"deg)\",\n      width: arrLineLength.pop() + \"px\",\n      height: 100 + \"px\",\n      from: {\n        left: window.innerWidth / 2,\n        top: window.innerHeight / 2,\n        width: 0 + \"px\",\n        height: 0 + \"px\",\n      },\n    }));\n\n    const [meaningStyle, setMeaningStyle] = useSpring(() => ({\n      config: config.stiff,\n      zIndex: 0,\n      opacity: 0,\n      // left: x,\n      width: window.innerWidth,\n      // top: y - (circleSize / (layer + 1)) * circleSizeRate,\n      fontSize: FontSize[0],\n      from: {\n        opacity: 0,\n        // left: window.innerWidth / 2,\n        // top: window.innerHeight / 2,\n      },\n      immediate: (key) => key === \"zIndex\",\n    }));\n\n    function click(word) {\n      // console.log(\"clicked\", word);\n      props.clickWordCard(word);\n      document.getElementById(\"searchInput\").value = word[\"word\"];\n    }\n\n    return (\n      <>\n        <animated.div\n          className={\"connectLine\"}\n          style={lineStyle}\n        ></animated.div>\n        <animated.div className={\"meaning\"} style={meaningStyle}>\n          <p>\n            <b>{word}</b>\n            <br></br>\n            {meanWord}\n          </p>\n          {wordDescription}\n        </animated.div>\n        <animated.div\n          className={\"word circleBase\"}\n          style={style}\n          onClick={() => {\n            {\n              if (!hasClicked) {\n                click({ word });\n              }\n            }\n          }}\n          onTouchEnd={(event) => {\n            setMeaningStyle({\n              opacity: 0,\n              zIndex: 0,\n              // top: y - (circleSize / (layer + 1)) * circleSizeRate,\n            });\n            setHasClicked(false);\n            setClicked(false);\n            setStyle({\n              config: config.stiff,\n              opacity: 1,\n              left: x,\n              top: y,\n              width: (circleSize / (layer + 1)) * circleSizeRate + \"px\",\n              height: (circleSize / (layer + 1)) * circleSizeRate + \"px\",\n            });\n          }}\n          onMouseLeave={(event) => {\n            setMeaningStyle({\n              opacity: 0,\n              zIndex: 0,\n              // top: y - (circleSize / (layer + 1)) * circleSizeRate,\n            });\n            setHasClicked(false);\n            setClicked(false);\n            setStyle({\n              config: config.stiff,\n              opacity: 1,\n              left: x,\n              top: y,\n              width: (circleSize / (layer + 1)) * circleSizeRate + \"px\",\n              height: (circleSize / (layer + 1)) * circleSizeRate + \"px\",\n            });\n          }}\n          // onMouseDown={(event) => {\n          //   setClicked(true);\n          //   setStyle({\n          //     opacity: 0.5,\n          //     left: event.clientX,\n          //     top: event.clientY,\n          //   });\n          // }}\n          // onMouseMove={(event) => {\n          //   if (clicked) {\n          //     setHasClicked(true);\n          //     setMeaningStyle({\n          //       zIndex: 999,\n          //     });\n          //     setStyle({\n          //       config: { duration: -1 },\n          //       left: event.clientX,\n          //       top: event.clientY,\n          //     });\n          //   }\n          // }}\n          onTouchStart={() => {\n            console.log(\"touchstart\");\n            setMeaningStyle({\n              zIndex: 999,\n              opacity: 0.8,\n              // top: y - (circleSize / (layer + 1)) * circleSizeRate,\n            });\n            setStyle({\n              opacity: 1,\n              width: (circleSize / (layer + 1)) * circleSizeRate * 1.1 + \"px\",\n              height: (circleSize / (layer + 1)) * circleSizeRate * 1.1 + \"px\",\n            });\n          }}\n          onMouseEnter={() => {\n            console.log(\"mouseenter\");\n            setMeaningStyle({\n              zIndex: 999,\n              opacity: 0.8,\n              // top: y - (circleSize / (layer + 1)) * circleSizeRate,\n            });\n            setStyle({\n              opacity: 1,\n              width: (circleSize / (layer + 1)) * circleSizeRate * 1.1 + \"px\",\n              height: (circleSize / (layer + 1)) * circleSizeRate * 1.1 + \"px\",\n            });\n          }}\n          key={word}\n        >\n          <p>{word}</p>\n        </animated.div>\n      </>\n    );\n  }\n\n  let layer = 0;\n  let id = 0;\n\n  return (\n    <>\n      {props.data.data.map((wordPKG) => (\n        <div className={layer++}>\n          {wordPKG.map((word, index) => (\n            <>\n              <CreateWordCard\n                key={word}\n                word={word}\n                posX={arrX[id]}\n                posY={arrY[id]}\n                layer={layer}\n                id={id++}\n                clickWordCard={props.clickWordCard}\n              />\n            </>\n          ))}\n        </div>\n      ))}\n    </>\n  );\n}\n\nconst EtymomapPresenter = ({\n  words,\n  searchTerm,\n  loading,\n  handleSubmit,\n  updateTerm,\n  clickWordCard,\n}) => (\n  <>\n    <div>\n      <form\n        width=\"100%\"\n        align=\"center\"\n        onSubmit={handleSubmit}\n        blurOnSubmit={true}\n        style={{ position: \"absolute\", top: \"0px\", left: \"0px\" }}\n      >\n        <input\n          id=\"searchInput\"\n          autoFocus={true}\n          placeholder=\"search\"\n          className=\"searchInput\"\n          // value={searchTerm}\n          onChange={updateTerm}\n        ></input>\n      </form>\n    </div>\n    {loading ? (\n      <>\n        <div key=\"loading\">\n          <p>여러분, 사랑합니다.</p>\n        </div>\n      </>\n    ) : (\n      <Welcome\n        key=\"wordCard\"\n        data={words}\n        loading={loading}\n        clickWordCard={clickWordCard}\n      />\n    )}\n  </>\n);\n\nexport default EtymomapPresenter;\n","import React, { useState, useEffect } from \"react\";\nimport \"./App.css\";\nimport \"./WordCards\";\n\nimport axios from \"axios\";\nimport EtymomapPresenter from \"./Routes/EtymomapPresenter\";\nimport hideVirtualKeyboard from \"hide-virtual-keyboard\";\n\nlet keyword = null;\n\nfunction Wordboard() {\n  const [words, setWords] = useState(null);\n  // const [wordStyle, setWordStyle] = useState([]);\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  function handleSubmit(event) {\n    event.preventDefault();\n    // console.log(\"T:\", searchTerm);\n    if (searchTerm !== keyword) {\n      setLoading(true);\n      setSearchTerm(keyword);\n    }\n  }\n\n  useEffect(() => {\n    if (keyword) {\n      searchByTerm(keyword);\n      // console.log(\"handle Submit: \", searchTerm);\n    }\n  }, [searchTerm]);\n\n  function updateTerm(event) {\n    // console.log(event.target.value);\n    let value = event.target.value;\n    keyword = value;\n  }\n  function clickWordCard(key) {\n    keyword = key.word;\n    // console.log(\"clickWordCard:\", key.word);\n    setLoading(true);\n    setSearchTerm(key);\n  }\n\n  async function searchByTerm(keyword) {\n    // console.log(\"Search:\" + keyword);\n    try {\n      await axios\n        .get(\"http://realchord.net/etymo/q3.php?p=\" + keyword)\n        .then(({ data }) => {\n          console.log(\"axios : \", { data });\n          setWords({ data });\n          hideVirtualKeyboard();\n        })\n        .catch((err) => {});\n    } catch {\n      setError(\"Can't find information.\");\n    } finally {\n      // console.log(\"finally : \", ?);\n      searchTerm && setLoading(false);\n    }\n  }\n\n  // componentWDidnmount() {}\n\n  return (\n    <EtymomapPresenter\n      words={words}\n      searchTerm={searchTerm}\n      error={error}\n      loading={loading}\n      handleSubmit={handleSubmit}\n      updateTerm={updateTerm}\n      clickWordCard={clickWordCard}\n    />\n  );\n}\n\nexport default Wordboard;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}